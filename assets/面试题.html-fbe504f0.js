import{_ as l,p as r,q as n,Q as e,a1 as a,R as i,t as d}from"./framework-204010b2.js";const s={},t=a(`<h1 id="面试题" tabindex="-1"><a class="header-anchor" href="#面试题" aria-hidden="true">#</a> 面试题</h1><h2 id="html" tabindex="-1"><a class="header-anchor" href="#html" aria-hidden="true">#</a> HTML</h2><h2 id="css" tabindex="-1"><a class="header-anchor" href="#css" aria-hidden="true">#</a> CSS</h2><h2 id="javascript" tabindex="-1"><a class="header-anchor" href="#javascript" aria-hidden="true">#</a> JavaScript</h2><h3 id="this-绑定" tabindex="-1"><a class="header-anchor" href="#this-绑定" aria-hidden="true">#</a> this 绑定</h3><h3 id="变量提升、函数提升" tabindex="-1"><a class="header-anchor" href="#变量提升、函数提升" aria-hidden="true">#</a> 变量提升、函数提升</h3><p>变量提升：</p><ul><li>简单说就是在 js 代码执⾏前引擎会先进⾏预编译，预编译期间会将变量声明与函数声明提升⾄其对 应作⽤域的最顶端，函数内声明的变量只会提升⾄该函数作⽤域最顶层。</li><li>当函数内部定义的⼀个变量与外部相同时，那么函数体内的这个变量就会被上升到最顶端。</li></ul><p>函数提升：</p><ul><li>函数提升只会提升函数声明式写法，函数表达式的写法不存在函数提升。</li><li>函数提升的优先级⼤于变量提升的优先级，即函数提升在变量提升之上。</li></ul><h3 id="go-ao-vo-的理解" tabindex="-1"><a class="header-anchor" href="#go-ao-vo-的理解" aria-hidden="true">#</a> GO/AO/VO 的理解</h3><p>GO</p><ul><li>Global Object JS 代码在执⾏前会现在堆内存中创建⼀个全局对象(GO)</li><li>⽤于存放⼀些定义好的变量⽅法等包含 Date Array String Number setTimeout 等</li><li>同时有⼀个 window 属性指向⾃⼰</li><li>同时在语法分析转成 AST 的过程中也会将⼀些变量 函数 存放在 GO 中 只是变量的初始值为 undefined</li></ul><p>AO</p><ul><li>函数在执⾏前会先在堆内存中创建⼀个 AO(Activation Object)对象 ⾥⾯存放这 arguments 对应函数的形参 以及在函数中定义的变量 初始值为 undefined</li></ul><p>VO</p><ul><li>Variable Object 在执⾏函数时 会在执⾏上下⽂栈(ECS)中进⼊⼀个函数执⾏上下⽂(FEC)其中有三个核⼼ 核⼼之⼀是 VO 指向的是该函数在内存中解析时创建的 AO ⽽在全局执⾏上下⽂中指向的是 GO</li></ul><h3 id="作用域和作用域链的理解" tabindex="-1"><a class="header-anchor" href="#作用域和作用域链的理解" aria-hidden="true">#</a> 作⽤域和作⽤域链的理解</h3><p>作⽤域</p><ul><li>在 ES5 中，全局是⼀个作⽤域，函数也会产⽣作⽤域。</li><li>在 ES6 中，代码块、let、const 等都会有属于⾃⼰的作⽤域。</li></ul><p>作⽤域链</p><ul><li>当进⼊到⼀个执⾏上下⽂时，执⾏上下⽂会关联⼀个作⽤域链。</li><li>通常作⽤域链在解析时就被确定，作⽤域链与函数的定义位置有关，与它的调⽤位置⽆关</li></ul><h3 id="如何理解闭包的-闭包到底是什么" tabindex="-1"><a class="header-anchor" href="#如何理解闭包的-闭包到底是什么" aria-hidden="true">#</a> 如何理解闭包的,闭包到底是什么?</h3><ul><li>⼀个普通的函数 function，如果它可以访问外层作⽤域的⾃由变量，那么这个函数和周围环境就是⼀个闭包。</li><li>应⽤场景:防抖 、节流 、⽴即执⾏函数 、组合函数等等</li></ul><h3 id="数组扁平化" tabindex="-1"><a class="header-anchor" href="#数组扁平化" aria-hidden="true">#</a> 数组扁平化</h3><div class="language-javaScript line-numbers-mode" data-ext="javaScript"><pre class="language-javaScript"><code>var arr = [1,2,[3,4]]
var result = []
result = [].concat(...arr)
result = arr.flat()
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="数组去重" tabindex="-1"><a class="header-anchor" href="#数组去重" aria-hidden="true">#</a> 数组去重</h3><div class="language-javaScript line-numbers-mode" data-ext="javaScript"><pre class="language-javaScript"><code>function unique (arr) {
  return Array.from(new Set(arr))
}
function unique(arr) {
  for(var i=0; i&lt;arr.length; i++){
        for(var j=i+1; j&lt;arr.length; j++){
                if(arr[i]==arr[j]){ //第⼀个等同于第⼆个，splice⽅法删除第⼆个
                    arr.splice(j,1);
                    j--;
                  }
              }
        }
  return arr;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="ts" tabindex="-1"><a class="header-anchor" href="#ts" aria-hidden="true">#</a> TS</h2><h2 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true">#</a> React</h2><h2 id="网络" tabindex="-1"><a class="header-anchor" href="#网络" aria-hidden="true">#</a> 网络</h2>`,31),h=a('<h3 id="模块化开发的理解" tabindex="-1"><a class="header-anchor" href="#模块化开发的理解" aria-hidden="true">#</a> 模块化开发的理解</h3><ul><li>模块化开发最终的⽬的是将程序划分成⼀个个⼩的结构(模块)</li><li>这个结构中编写属于⾃⼰的逻辑代码，有⾃⼰的作⽤域，定义变量名词时不会影响到其他的结构</li><li>可导出变量,函数,对象等给其他模块⽤，也可导⼊其他模块中的变量,函数,对象</li><li>按照这种结构划分开发程序的过程，就是模块化开发的过程</li><li>早期是没有模块化, 带来⼀些问题 <ul><li>命名冲突 -&gt; ⽴即执⾏函数 -&gt; ⾃定义模块 -&gt; 没有规范</li><li>社区中模块化规范: CommonJS/AMD/CMD</li><li>ES6 中推出模块化: ES Module</li></ul></li></ul><h3 id="什么是-yarn-和-npm-为什么要用-yarn-代替-npm-呢" tabindex="-1"><a class="header-anchor" href="#什么是-yarn-和-npm-为什么要用-yarn-代替-npm-呢" aria-hidden="true">#</a> 什么是 yarn 和 npm？为什么要⽤ yarn 代替 npm 呢？</h3><ul><li>npm 是与 Node.js ⾃带的默认包管理器，它有⼀个⼤型的公共库和私有库，存储在 npm registry 的数据库中，⽤户可以通过 npm 命令⾏访问该仓库。在 npm 的帮助下，⽤户可以轻松管理项⽬中的依赖项。</li><li>yarn 也是⼀个包管理器，是由 Facebook、Google、Exponent 和 Tilde 联合推出了⼀个新的 JS 包 管理⼯具，它有如下的优点： <ol><li>速度快，⽀持并⾏安装。⽆论 npm 还是 Yarn 在执⾏包的安装时，都会执⾏⼀系列任务。 npm 是按照队列执⾏每个 package，也就是说必须要等到当前 package 安装完成之后，才 能继续后⾯的安装。⽽ Yarn 是同步执⾏所有任务，提⾼了性能。</li><li>离线模式，如果之前已经安装过⼀个软件包，⽤ Yarn 再次安装时之间从缓存中获取，就不⽤ 像 npm 那样再从⽹络下载了。</li></ol></li><li>yarn 是为了弥补 早期 npm 的⼀些缺陷⽽出现的，⽐如安装依赖速度很慢、版本依赖混乱等等⼀系列的问题， npm5 版本开始，进⾏了很多的升级和改进。</li></ul><h3 id="npm-install-的安装过程" tabindex="-1"><a class="header-anchor" href="#npm-install-的安装过程" aria-hidden="true">#</a> npm install 的安装过程</h3><p>执⾏ npm install 会检测是有 package-lock.json ⽂件：</p><ol><li>没有 lock ⽂件 <ul><li>分析依赖关系，这是因为我们可能包会依赖其他的包，并且多个包之间会产⽣相同依赖的情况；</li><li>从 registry 仓库中下载压缩包（如果我们设置了镜像，那么会从镜像服务器下载压缩包）；</li><li>获取到压缩包后会对压缩包进⾏缓存（从 npm5 开始有的）；</li><li>将压缩包解压到项⽬的 node_modules ⽂件夹中（前⾯我们讲过，require 的查找顺序会在该包下⾯查找）</li></ul></li><li>有 lock ⽂件 <ul><li>检测 lock 中包的版本是否和 package.json 中⼀致（会按照 semver 版本规范检测）</li><li>不⼀致，那么会重新构建依赖关系，直接会⾛顶层的流程</li><li>⼀致的情况下，会去优先查找缓存 <ul><li>没有找到，会从 registry 仓库下载，直接⾛顶层流程</li><li>查找到，会获取缓存中的压缩⽂件，并且将压缩⽂件解压到 node_modules ⽂件夹中</li></ul></li></ul></li></ol><h3 id="什么是-pnpm-为什么说-pnpm-高性能" tabindex="-1"><a class="header-anchor" href="#什么是-pnpm-为什么说-pnpm-高性能" aria-hidden="true">#</a> 什么是 pnpm？为什么说 pnpm ⾼性能？</h3><ul><li>pnpm 是⼀个快速、节省磁盘空间的软件包管理器，特点是：快速、⾼效，并⽀持 monorepo 等等。</li><li>当使⽤ npm 或 Yarn 时，如果你有 100 个项⽬，并且所有项⽬都有⼀个相同的依赖包，那么， 你在硬盘上就需要保存 100 份该相同依赖包的副本。为了解决上⾯的问题，就出现了 pnpm，使⽤ pnpm 安装的依赖包将被存放在⼀个统⼀的位置。 <ul><li>当安装软件包时， 其包含的所有⽂件都会硬链接到此位置，⽽不会占⽤额外的硬盘空间</li><li>pnpm 是软连接和硬链接相结合，⽅便在项⽬之间共享相同版本的依赖包</li></ul></li></ul>',9),c=i("h3",{id:"git-flow",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#git-flow","aria-hidden":"true"},"#"),d(" git flow")],-1),u=i("p",null,"由于 Git 上分支的使用的便捷性，产生了很多 Git 的工作流：",-1),o=i("ul",null,[i("li",null,"master 分支：主要包含最近发布到生产环境的代码，最近发布的 release，这个分支只能从其他分支合并，不能在这个分支直接修改"),i("li",null,"develop 分支：主要开发分支，包含所有要发布到下一个 release 的代码"),i("li",null,"feature 分支：开发一个新的功能，一旦开发完成，合并回 develop 分支"),i("li",null,"release 分支：当需要发布新的测试版本，我们基于 develop 分支创建一个 release 分支，完成 release 后，我们合并到 master 和 develop"),i("li",null,"hotfix 分支：当我们在 master 发现新的 bug 时，我们需要创建一个 hotfix，完成 hotfix 后，合并回 master 和 develop 分支，所以 hotfix 的改动回进入下一个 release")],-1);function p(m,v){return r(),n("div",null,[t,e(" ## 前端工程化 "),h,e(" ## Git "),e(" ### 常见 git 命令 "),c,u,o])}const f=l(s,[["render",p],["__file","面试题.html.vue"]]);export{f as default};
