import{_ as e,p as r,q as i,a1 as l}from"./framework-204010b2.js";const a="/blog/img/web/browser/url渲染.jpg",t="/blog/img/web/browser/renderingEngine.jpg",n="/blog/img/web/browser/render流程.jpg",d="/blog/img/web/browser/dom-tree.jpg",o="/blog/img/web/browser/cssom.jpg",s="/blog/img/web/browser/render-tree.jpg",h="/blog/img/web/browser/render-end.jpg",p={},c=l('<h1 id="浏览器相关知识" tabindex="-1"><a class="header-anchor" href="#浏览器相关知识" aria-hidden="true">#</a> 浏览器相关知识</h1><h2 id="浏览器渲染原理" tabindex="-1"><a class="header-anchor" href="#浏览器渲染原理" aria-hidden="true">#</a> 浏览器渲染原理</h2><h3 id="网页被解析的过程" tabindex="-1"><a class="header-anchor" href="#网页被解析的过程" aria-hidden="true">#</a> 网页被解析的过程</h3><p><img src="'+a+'" alt="url渲染"></p><p>也就是一个网页下载下来后，就是由我们的渲染引擎来帮助我们解析的。</p><h3 id="浏览器的内核" tabindex="-1"><a class="header-anchor" href="#浏览器的内核" aria-hidden="true">#</a> 浏览器的内核</h3><p>浏览器最核心的部分是渲染引擎（Rendering Engine）, 一般也称为<strong>浏览器内核</strong></p><p>常见的浏览器内核：</p><ul><li><strong>Trident</strong> （ 三叉戟）：IE、360 安全浏览器、搜狗高速浏览器、百度浏览器、UC 浏览器</li><li><strong>Gecko</strong>（ 壁虎） ：Mozilla Firefox</li><li><strong>Webkit</strong> ：Safari、360 极速浏览器、搜狗高速浏览器、移动端浏览器（Android、iOS）</li><li><strong>Webkit</strong>（分支） -&gt; <strong>Blink</strong> ：Google Chrome</li></ul><p><img src="'+t+'" alt="浏览器内核"></p><p>不同的浏览器内核有不同的解析、渲染规则，所以同一网页在不同内核的浏览器中的渲染效果也可能不同。(所以我们要进行浏览器适配，当然现在有各种打包工具帮助我们进行适配了)</p><h3 id="渲染引擎解析页面" tabindex="-1"><a class="header-anchor" href="#渲染引擎解析页面" aria-hidden="true">#</a> 渲染引擎解析页面</h3><p><img src="'+n+'" alt="render流程"></p><h4 id="html-解析过程" tabindex="-1"><a class="header-anchor" href="#html-解析过程" aria-hidden="true">#</a> HTML 解析过程</h4><ul><li>默认情况下服务器会给浏览器返回 index.html 文件，所以解析 HTML 是所有步骤的开始：</li><li>解析 HTML，会构建 DOM Tree：</li></ul><p><img src="'+d+'" alt="dom-tree"></p><h4 id="生成-css-规则" tabindex="-1"><a class="header-anchor" href="#生成-css-规则" aria-hidden="true">#</a> 生成 CSS 规则</h4><ul><li>在解析的过程中，如果遇到 CSS 的 link 元素，那么会由浏览器负责下载对应的 CSS 文件： <ul><li>下载 CSS 文件是不会影响 DOM 的解析的；</li></ul></li><li>浏览器下载完 CSS 文件后，就会对 CSS 文件进行解析，解析出对应的规则树： <ul><li>我们可以称之为 CSSOM（CSS Object Model，CSS 对象模型）；</li></ul></li></ul><p><img src="'+o+'" alt="cssom"></p><h4 id="构建-render-tree" tabindex="-1"><a class="header-anchor" href="#构建-render-tree" aria-hidden="true">#</a> 构建 Render Tree</h4><p>当有了 DOM Tree 和 CSSOM Tree 后，就可以两个结合来构建 Render Tree 了</p><p><img src="'+s+'" alt="render-tree"></p><p>注意一：link 元素不会阻塞 DOM Tree 的构建过程，但是会阻塞 Render Tree 的构建过程</p><ul><li>这是因为 Render Tree 在构建时，需要对应的 CSSOM Tree；</li></ul><p>注意二：Render Tree 和 DOM Tree 并不是一一对应的关系，比如对于 display 为 none 的元素，压根不会出现在 render tree 中；</p><h4 id="布局-layout-和绘制-paint" tabindex="-1"><a class="header-anchor" href="#布局-layout-和绘制-paint" aria-hidden="true">#</a> 布局（layout）和绘制（Paint）</h4><ul><li>第四步是在渲染树（Render Tree）上运行布局（Layout）以计算每个节点的几何体。 <ul><li>渲染树会表示显示哪些节点以及其他样式，但是不表示每个节点的尺寸、位置等信息；</li><li>布局是确定呈现树中所有节点的宽度、高度和位置信息；</li></ul></li><li>第五步是将每个节点绘制（Paint）到屏幕上 <ul><li>在绘制阶段，浏览器将布局阶段计算的每个 frame 转为屏幕上实际的像素点；</li><li>包括将元素的可见部分进行绘制，比如文本、颜色、边框、阴影、替换元素（比如 img）</li></ul></li></ul><p><img src="'+h+'" alt="render-end"></p><h3 id="回流和重绘" tabindex="-1"><a class="header-anchor" href="#回流和重绘" aria-hidden="true">#</a> 回流和重绘</h3><h4 id="回流-reflow-也可以称之为重排" tabindex="-1"><a class="header-anchor" href="#回流-reflow-也可以称之为重排" aria-hidden="true">#</a> 回流 reflow：（也可以称之为重排）</h4><ul><li>第一次确定节点的大小和位置，称之为布局（layout）。</li><li>之后对节点的大小、位置修改重新计算称之为回流。</li></ul><p>什么情况下引起回流</p><ul><li>比如 DOM 结构发生改变（添加新的节点或者移除节点）；</li><li>比如改变了布局（修改了 width、height、padding、font-size 等值）</li><li>比如窗口 resize（修改了窗口的尺寸等）</li><li>比如调用 getComputedStyle 方法获取尺寸、位置信息；</li></ul><h4 id="理解重绘-repaint" tabindex="-1"><a class="header-anchor" href="#理解重绘-repaint" aria-hidden="true">#</a> 理解重绘 repaint</h4><ul><li>第一次渲染内容称之为绘制（paint）。</li><li>之后重新渲染称之为重绘。</li></ul><p>什么情况下会引起重绘呢？</p><ul><li>比如修改背景色、文字颜色、边框颜色、样式等；</li></ul><p>回流一定会引起重绘，所以回流是一件很消耗性能的事情。所以在开发中要尽量避免发生回流：</p><ol><li>修改样式时尽量一次性修改 <ul><li>比如通过 cssText 修改，比如通过添加 class 修改</li></ul></li><li>尽量避免频繁的操作 DOM <ul><li>我们可以在一个 DocumentFragment 或者父元素中 将要操作的 DOM 操作完成，再一次性的操作；</li></ul></li><li>尽量避免通过 getComputedStyle 获取尺寸、位置等信 息；</li><li>对某些元素使用 position 的 absolute 或者 fixed <ul><li>并不是不会引起回流，而是开销相对较小，不会对 其他元素造成影响。</li></ul></li></ol>',39),u=[c];function g(m,b){return r(),i("div",null,u)}const f=e(p,[["render",g],["__file","browser.html.vue"]]);export{f as default};
