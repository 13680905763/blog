<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.60">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>how to use git | 悲伤猪的博客</title><meta name="description" content="i am sadPig">
    <link rel="preload" href="/blog/assets/style-693152cb.css" as="style"><link rel="stylesheet" href="/blog/assets/style-693152cb.css">
    <link rel="modulepreload" href="/blog/assets/app-b6176fc1.js"><link rel="modulepreload" href="/blog/assets/framework-204010b2.js"><link rel="modulepreload" href="/blog/assets/git.html-d5737f39.js"><link rel="modulepreload" href="/blog/assets/git.html-db0c04e9.js"><link rel="prefetch" href="/blog/assets/index.html-501223e4.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-8194a163.js" as="script"><link rel="prefetch" href="/blog/assets/word.html-72a6bc91.js" as="script"><link rel="prefetch" href="/blog/assets/open-source-protocol.html-1c1b5024.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-8db40d2b.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-c39effd0.js" as="script"><link rel="prefetch" href="/blog/assets/2023.html-1c0fb4f3.js" as="script"><link rel="prefetch" href="/blog/assets/chrome.html-a3f3ac79.js" as="script"><link rel="prefetch" href="/blog/assets/information.html-607c10de.js" as="script"><link rel="prefetch" href="/blog/assets/vscode.html-bea34c4a.js" as="script"><link rel="prefetch" href="/blog/assets/less.html-26fd1ddf.js" as="script"><link rel="prefetch" href="/blog/assets/background.html-382ad5e5.js" as="script"><link rel="prefetch" href="/blog/assets/bfc.html-e47e3336.js" as="script"><link rel="prefetch" href="/blog/assets/box-model.html-35481d99.js" as="script"><link rel="prefetch" href="/blog/assets/css-function.html-fd6dfcb4.js" as="script"><link rel="prefetch" href="/blog/assets/css.html-b9423d8e.js" as="script"><link rel="prefetch" href="/blog/assets/css单位.html-598f2b7c.js" as="script"><link rel="prefetch" href="/blog/assets/flex.html-3161de70.js" as="script"><link rel="prefetch" href="/blog/assets/float.html-f4280873.js" as="script"><link rel="prefetch" href="/blog/assets/font.html-2a6c8512.js" as="script"><link rel="prefetch" href="/blog/assets/other-property.html-31eb82f2.js" as="script"><link rel="prefetch" href="/blog/assets/position.html-11f78fca.js" as="script"><link rel="prefetch" href="/blog/assets/selectors.html-b42fb5c3.js" as="script"><link rel="prefetch" href="/blog/assets/transform.html-d3136356.js" as="script"><link rel="prefetch" href="/blog/assets/媒体查询.html-e4dfdada.js" as="script"><link rel="prefetch" href="/blog/assets/常用属性.html-9daab5ac.js" as="script"><link rel="prefetch" href="/blog/assets/移动端适配.html-498427cd.js" as="script"><link rel="prefetch" href="/blog/assets/继承-层叠-元素类型.html-c4877969.js" as="script"><link rel="prefetch" href="/blog/assets/过渡动画.html-be3d1ed4.js" as="script"><link rel="prefetch" href="/blog/assets/element.html-c70c39f9.js" as="script"><link rel="prefetch" href="/blog/assets/element2.html-40cf7cd7.js" as="script"><link rel="prefetch" href="/blog/assets/html.html-508b7edf.js" as="script"><link rel="prefetch" href="/blog/assets/html5-element.html-151b1fd8.js" as="script"><link rel="prefetch" href="/blog/assets/other.html-8f038354.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-539faacb.js" as="script"><link rel="prefetch" href="/blog/assets/404.html-f9875e7b.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-448167a8.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-3dce8afc.js" as="script"><link rel="prefetch" href="/blog/assets/word.html-2531928b.js" as="script"><link rel="prefetch" href="/blog/assets/open-source-protocol.html-97e2f82b.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-7cfa0a6c.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-fdd695f4.js" as="script"><link rel="prefetch" href="/blog/assets/2023.html-fea8a9be.js" as="script"><link rel="prefetch" href="/blog/assets/chrome.html-9c222587.js" as="script"><link rel="prefetch" href="/blog/assets/information.html-4444f910.js" as="script"><link rel="prefetch" href="/blog/assets/vscode.html-aa4f3d26.js" as="script"><link rel="prefetch" href="/blog/assets/less.html-bd2ef685.js" as="script"><link rel="prefetch" href="/blog/assets/background.html-4b188c45.js" as="script"><link rel="prefetch" href="/blog/assets/bfc.html-a1c086d6.js" as="script"><link rel="prefetch" href="/blog/assets/box-model.html-34106453.js" as="script"><link rel="prefetch" href="/blog/assets/css-function.html-e5c141c2.js" as="script"><link rel="prefetch" href="/blog/assets/css.html-01196ed1.js" as="script"><link rel="prefetch" href="/blog/assets/css单位.html-18534d6b.js" as="script"><link rel="prefetch" href="/blog/assets/flex.html-01c50397.js" as="script"><link rel="prefetch" href="/blog/assets/float.html-02470c48.js" as="script"><link rel="prefetch" href="/blog/assets/font.html-0f38b115.js" as="script"><link rel="prefetch" href="/blog/assets/other-property.html-af3719b2.js" as="script"><link rel="prefetch" href="/blog/assets/position.html-5c523b4c.js" as="script"><link rel="prefetch" href="/blog/assets/selectors.html-4d6bc73a.js" as="script"><link rel="prefetch" href="/blog/assets/transform.html-42b42225.js" as="script"><link rel="prefetch" href="/blog/assets/媒体查询.html-ccf82c01.js" as="script"><link rel="prefetch" href="/blog/assets/常用属性.html-e090ea37.js" as="script"><link rel="prefetch" href="/blog/assets/移动端适配.html-9ac59d3e.js" as="script"><link rel="prefetch" href="/blog/assets/继承-层叠-元素类型.html-26bea85d.js" as="script"><link rel="prefetch" href="/blog/assets/过渡动画.html-88fd0408.js" as="script"><link rel="prefetch" href="/blog/assets/element.html-a75c9f70.js" as="script"><link rel="prefetch" href="/blog/assets/element2.html-76322e58.js" as="script"><link rel="prefetch" href="/blog/assets/html.html-8a2d3bd2.js" as="script"><link rel="prefetch" href="/blog/assets/html5-element.html-480ceb80.js" as="script"><link rel="prefetch" href="/blog/assets/other.html-41e354cd.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-e14a5d95.js" as="script"><link rel="prefetch" href="/blog/assets/404.html-d1e63d77.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/blog/" class=""><img class="logo" src="http://caibaojian.com/vuepress/hero.png" alt="悲伤猪的博客"><span class="site-name can-hide">悲伤猪的博客</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/blog/" class="" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/web/" class="" aria-label="web-note"><!--[--><!--]--> web-note <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/programming/" class="router-link-active" aria-label="programming"><!--[--><!--]--> programming <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/other/" class="" aria-label="other"><!--[--><!--]--> other <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/13680905763" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://juejin.cn/user/215917184954583" rel="noopener noreferrer" target="_blank" aria-label="掘金"><!--[--><!--]--> 掘金 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/blog/" class="" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/web/" class="" aria-label="web-note"><!--[--><!--]--> web-note <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/programming/" class="router-link-active" aria-label="programming"><!--[--><!--]--> programming <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/other/" class="" aria-label="other"><!--[--><!--]--> other <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/13680905763" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://juejin.cn/user/215917184954583" rel="noopener noreferrer" target="_blank" aria-label="掘金"><!--[--><!--]--> 掘金 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/blog/programming/git.md" class="sidebar-item sidebar-heading active" aria-label="git"><!--[--><!--]--> git <!--[--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="how-to-use-git" tabindex="-1"><a class="header-anchor" href="#how-to-use-git" aria-hidden="true">#</a> how to use git</h1><h2 id="concept" tabindex="-1"><a class="header-anchor" href="#concept" aria-hidden="true">#</a> concept</h2><h3 id="集中式版本控制" tabindex="-1"><a class="header-anchor" href="#集中式版本控制" aria-hidden="true">#</a> 集中式版本控制</h3><p>CVS 和 SVN 都是是属于集中式版本控制系统</p><ol><li>单一的<strong>集中管理的服务器</strong>，保存所有文件的修订版本；</li><li>开发人员通过客户端连接到这台服务器，取出最新的文件或者提交更新；</li></ol><ul><li>相较于老式的本地管理来说，每个人都可以在一定程度上看到项目中的 其他人正在做些什么。</li><li>有一个核心的问题：中央服务器不能出现故障： <ol><li>如果宕机一小时，那么在这一小时内，谁都无法提 交更新，也就无法协同工作；</li><li>如果中心数据库所在的磁盘发生损坏，又没有做恰 当备份，毫无疑问你将丢失所有数据；</li></ol></li></ul><h3 id="分布式版本控制" tabindex="-1"><a class="header-anchor" href="#分布式版本控制" aria-hidden="true">#</a> 分布式版本控制</h3><ul><li>客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下 来，包括完整的历史记录；</li><li>任何一处协同工作用的服务器发生故障，事后都可以用任何 一个镜像出来的本地仓库恢复；</li><li>因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份；</li></ul><h2 id="bash-–-cmd-–-gui" tabindex="-1"><a class="header-anchor" href="#bash-–-cmd-–-gui" aria-hidden="true">#</a> Bash – CMD – GUI</h2><ul><li>Git Bash 是基于 CMD 的，在 CMD 的基础上增添一些新的命令与功能；</li><li>Git CMD 命令行提示符（CMD）是 Windows 操作系统上的命令行解释程序</li><li>Git GUI 提供了一个图形用户界面来运行 git 命令；</li></ul><h2 id="config" tabindex="-1"><a class="header-anchor" href="#config" aria-hidden="true">#</a> config</h2><h3 id="username-usereamil" tabindex="-1"><a class="header-anchor" href="#username-usereamil" aria-hidden="true">#</a> username usereamil</h3><ul><li>每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改；</li><li>如果使用了 --global 选项，那么该命令只需要运行一次，之后无论你在该系统上做任何事情，Git 都会使用那些信息；</li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git config --global user.name <span class="token string">&#39;ZhangYuHua&#39;</span>
git config --global user.email <span class="token string">&#39;177748749@qq.com&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>检测当前配置信息</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git config --list
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="alias" tabindex="-1"><a class="header-anchor" href="#alias" aria-hidden="true">#</a> alias</h3><p>如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commmit
git config --global alias.st status
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="init" tabindex="-1"><a class="header-anchor" href="#init" aria-hidden="true">#</a> init</h2><ol><li>初始化仓库 git init</li><li>从远程克隆仓库 git clone</li></ol><h2 id="文件的状态" tabindex="-1"><a class="header-anchor" href="#文件的状态" aria-hidden="true">#</a> 文件的状态</h2><p>在 git 仓库中会对文件划分不同的状态</p><ol><li>Untracked:未跟踪, 此文件在文件夹中, 但并没有加入到 git 库, 不参与版本控制. 通过 git add 状态变为 Staged</li><li>Staged: 暂存状态. <ul><li>执行 git commit 则将修改同步到库中, 文件为 Unmodified 状态</li><li>执行 git reset HEAD filename 取消暂存, 文件状态为 Modified</li></ul></li><li>Unmodified：文件已经入库, 库中的文件和本地文件又变为一致. <ul><li>如果它被修改, 而变为 Modified.</li><li>执行 git rm 移出版本库, 则成为 Untracked 文件</li></ul></li><li>Modified：文件已修改, 仅仅是修改, 并没有进行其他的操作. <ul><li>执行 git add 可进入暂存 staged 状态,</li><li>执行 git checkout（从库中取出文件, 覆盖当前修改） 则丢弃修改过, 返回到 Unmodified 状态</li></ul></li></ol><p><img src="/blog/img/programming/git/status.jpg" alt="status"></p><h3 id="检测文件的状态" tabindex="-1"><a class="header-anchor" href="#检测文件的状态" aria-hidden="true">#</a> 检测文件的状态</h3><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git status
git status --short
git status -s
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="git-忽略文件" tabindex="-1"><a class="header-anchor" href="#git-忽略文件" aria-hidden="true">#</a> git 忽略文件</h2><p>有些文件我们无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。</p><ul><li>通常都是些自动生成的文件，比如依赖文件，日志文件，或者编译过程中创建 的临时文件等；</li><li>我们可以创建一个名为 <strong>.gitignore</strong> 的文件，列出要忽略的文件的模 式；</li></ul><h2 id="git-add" tabindex="-1"><a class="header-anchor" href="#git-add" aria-hidden="true">#</a> git add</h2><p>文件添加到暂存区</p><ul><li>跟踪新文件</li><li>跟踪已修改的文件</li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code> git add xx.js
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>将所有的文件添加到暂存区</li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code> git add .
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="git-commit" tabindex="-1"><a class="header-anchor" href="#git-commit" aria-hidden="true">#</a> git commit</h2><p>暂存区已经准备就绪，可以提交了</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git commit –m <span class="token string">&quot;提交信息&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>add 跟 commit 一起使用</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git commit -a -m <span class="token string">&quot;提交信息&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="commit-object" tabindex="-1"><a class="header-anchor" href="#commit-object" aria-hidden="true">#</a> commit Object</h3><p>在进行提交操作时，Git 会保存一个提交对象（commit object）：</p><ul><li>该提交对象会包含一个指向暂存内容快照的指针(校验和)；</li><li>该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针； <ul><li>首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象；</li><li>而由多个分支合并产生的提交对象有多个父对象；</li></ul></li></ul><p><img src="/blog/img/programming/git/commit1.jpg" alt="commit1"><img src="/blog/img/programming/git/commit2.jpg" alt="commit2"><img src="/blog/img/programming/git/commit3.jpg" alt="commit3"></p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git cat-file -t 文件名（二进制，前几位就行）// 看文件类型
git cat-file -p 文件名 // 看文件内容
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="/blog/img/programming/git/cat-file.jpg" alt="cat-file"></p><h2 id="git-校验和" tabindex="-1"><a class="header-anchor" href="#git-校验和" aria-hidden="true">#</a> git 校验和</h2><p>Git 中所有的数据在存储前都计算校验和，然后以 校验和 来引用。</p><ul><li>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）；</li><li>这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来；</li></ul><h2 id="git-log" tabindex="-1"><a class="header-anchor" href="#git-log" aria-hidden="true">#</a> git log</h2><p>要查看一下所有的历史提交记录。</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git log //列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明
git log --pretty=oneline // 只显示哈希值和提交说明
git log --pretty=oneline --graph // 可以看merge
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="git-reset" tabindex="-1"><a class="header-anchor" href="#git-reset" aria-hidden="true">#</a> git reset</h2><p>版本回退 HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交； <img src="/blog/img/programming/git/head.jpg" alt="HEAD"> 通过 HEAD 来改变 Git 目前的版本指向：</p><ul><li>上一个版本就是 HEAD^，上上一个版本就是 HEAD^^；</li><li>如果是上 1000 个版本，我们可以使用 HEAD~1000；</li><li>我们可以可以指定某一个 commit id；</li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git reset --hard HEAD^
git reset --hard HEAD~1000
git reset --hard 2d44982
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="远程仓库" tabindex="-1"><a class="header-anchor" href="#远程仓库" aria-hidden="true">#</a> 远程仓库</h2><p>多人开发中我们会将管理的代码共享到远程仓库中；</p><p>对于私有的仓库我们想要进行操作，远程仓库会对我们的身份进行验证：</p><ol><li>基于 HTTP 的凭证存储（Credential Storage）；</li><li>基于 SSH 的密钥；</li></ol><h3 id="凭证" tabindex="-1"><a class="header-anchor" href="#凭证" aria-hidden="true">#</a> 凭证</h3><p>HTTP 协议是无状态的连接，所以每一个连接都需要用户名和密码：</p><ul><li>如果每次都这样操作，那么会非常麻烦；</li><li>幸运的是，Git 拥有一个凭证系统来处理这个事情；</li></ul><h3 id="ssh-密钥" tabindex="-1"><a class="header-anchor" href="#ssh-密钥" aria-hidden="true">#</a> SSH 密钥</h3><p>Secure Shell（安全外壳协议，简称 SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。 SSH 以非对称加密实现身份验证。</p><ul><li>例如其中一种方法是使用自动生成的公钥-私钥对来简单地加密网络连接，随后使用密码认证进行登录；</li><li>另一种方法是人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录；</li><li>公钥需要放在待访问的电脑之中，而对应的私钥需要由用户自行保管；</li></ul><p>如果我们以 SSH 的方式访问 Git 仓库，那么就需要生产对应的公钥和私钥</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>ssh-keygen -t ed25519 -C “your email&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="管理远程服务器" tabindex="-1"><a class="header-anchor" href="#管理远程服务器" aria-hidden="true">#</a> 管理远程服务器</h3><p>查看远程仓库</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git remote
git remote -v
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>添加远程仓库</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git remote add &lt;shortname&gt; &lt;url&gt;
git remote add origin https://github.com/13680905763/blog.git
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>重命名远程仓库</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git remote rename origin 666
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>移除远程仓库</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git remote remove origin
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="本地分支的上游分支-跟踪分支" tabindex="-1"><a class="header-anchor" href="#本地分支的上游分支-跟踪分支" aria-hidden="true">#</a> 本地分支的上游分支（跟踪分支）</h3><p>本地的主分支是 master，远程的主分支是 main</p><p>当我们在本地进行 git pull（git pull = git fetch + git merge） 时</p><p>(git fetch 从远程获取新数据，到 git)提示我们当前分支没有 track 的分支</p><p><img src="/blog/img/programming/git/notrack.jpg" alt="notrack"></p><p>我们设置本地 master 分支跟踪远程 main 分支</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git branch --set-upstream-to=origin/main
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="/blog/img/programming/git/set-upstream-to.jpg" alt="set-upstream-to"></p><p>继续 git pull</p><p>(git merge 合并从远程拿到的新数据到当前分支，更新目录)提示我们拒绝合并不相干的历史</p><p><img src="/blog/img/programming/git/拒绝合并不相干历史.jpg" alt="拒绝合并不相干历史"></p><p>我们可以通过--allow-unrelated-histories 选项来允许合并两个不相关的历史；</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git merge allow-unrelated-histories
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="/blog/img/programming/git/allow-unrelated-histories.jpg" alt="allow-unrelated-histories"></p><h3 id="远程仓库的交互" tabindex="-1"><a class="header-anchor" href="#远程仓库的交互" aria-hidden="true">#</a> 远程仓库的交互</h3><ul><li>从远程仓库 clone 代码</li><li>将代码 push 到远程仓库：将本地仓库的代码推送到远程仓库中；</li><li>从远程仓库 fetch 代码：从远程仓库获取最新的代码</li><li>获取到代码后默认并没有合并到本地仓库，我们需要通过 merge 来合并；</li><li>从远程仓库 pull 代码：上面的两次操作有点繁琐，我们可以通过一个命令来操作</li></ul><h2 id="合并冲突" tabindex="-1"><a class="header-anchor" href="#合并冲突" aria-hidden="true">#</a> 合并冲突</h2><p>文件冲突时，需要合并</p><h2 id="tag" tabindex="-1"><a class="header-anchor" href="#tag" aria-hidden="true">#</a> tag</h2><p>对于重大的版本我们常常会打上一个标签，以表示它的重要性：</p><ul><li>Git 可以给仓库历史中的某一个提交打上标签；</li><li>比较有代表性的是人们会使用这个功能来标记发布结点（ v1.0 、 v2.0 等等）；</li></ul><p>创建标签：</p><ul><li>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）；</li><li>附注标签：通过-a 选项，并且通过-m 添加额外信息；</li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git tag v1.0
git tag -a v1.0 -m <span class="token string">&#39;附注标签&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>默认情况下，git push 不会传送标签到远程仓库服务器上。</p><ul><li>在创建标签后你必推送标签到远程仓库，其他人从仓库中克隆或拉取时也能得到标签；</li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git push origin v1.0
git push origin --tags // 推送所有标签
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>删除标签</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git tag -d v1.0 // 删除本地标签
git push origin --delete v1.0 //删除远程标签
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>检出标签</p><ul><li>查看某个标签所指向的文件版本，可以使用 git checkout 命令；</li><li>通常我们在检出 tag 的时候还会创建一个对应的分支（修复 bug）；</li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git checkout v1.0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="branch" tabindex="-1"><a class="header-anchor" href="#branch" aria-hidden="true">#</a> branch</h2><h3 id="master-分支" tabindex="-1"><a class="header-anchor" href="#master-分支" aria-hidden="true">#</a> master 分支</h3><p>Git 的分支，其实本质上是指向 commit object 的可变指针。</p><ul><li>Git 的默认分支名字是 master，在多次提交操作之后，master 分支始终指向最新的提交</li></ul><p>Git 的 master 分支并不是一个特殊分支。</p><ul><li>它就跟其它分支完全没有区别；</li><li>之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它；</li></ul><p><img src="/blog/img/programming/git/master.jpg" alt="master"></p><h3 id="创建分支" tabindex="-1"><a class="header-anchor" href="#创建分支" aria-hidden="true">#</a> 创建分支</h3><p>Git 是怎么创建新分支的呢？</p><ul><li>很简单，它只是为你创建了一个可以移动的新的指针； <ul><li>比如，创建一个 testing 分支， 你需要使用 git branch 命令：</li></ul></li></ul><p><img src="/blog/img/programming/git/test-branch.jpg" alt="test-branch"></p><ul><li>那么，Git 又是怎么知道当前在哪一个分支上呢？ <ul><li>也很简单，它也是通过一个名为 HEAD 的特殊指针；</li></ul></li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git checkout testing
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="/blog/img/programming/git/head-branch.jpg" alt="head-branch"></p><h3 id="分支提交" tabindex="-1"><a class="header-anchor" href="#分支提交" aria-hidden="true">#</a> 分支提交</h3><p>如果我们切换分支，并在这个分支上提交</p><p><img src="/blog/img/programming/git/test-commit.jpg" alt="test-commit"></p><p>切回 master 开发</p><p><img src="/blog/img/programming/git/checkout-master.jpg" alt="checkout-master"><img src="/blog/img/programming/git/master-commit.jpg" alt="master-commit"></p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git checkout -b &lt;newbranch&gt; // 创建分支并切换分支
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="为什么使用分支" tabindex="-1"><a class="header-anchor" href="#为什么使用分支" aria-hidden="true">#</a> 为什么使用分支</h3><p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。</p><ul><li>开发某个项目，在默认分支 master 上进行开发；</li><li>实现项目的功能需求，不断提交；</li><li>并且在一个大的版本完成时，发布版本，打上一个 tag v1.0.0；</li></ul><p>继续开发后续的新功能，突然线上 v1.0 出现了 bug 需要紧急修补</p><ul><li>切换到 tag v1.0.0 的版本，并且创建一个分支 hotfix；</li></ul><p><img src="/blog/img/programming/git/hotfix.jpg" alt="hotfix"></p><p>分支上开发、修复 bug：</p><ul><li>我们可以在创建的 hotfix 分支上继续开发工作或者修复 bug；</li><li>当完成要做的工作后，重新打上一个新的 tag v1.0.1；</li></ul><p>切换回 master 分支，但是这个时候 master 分支也需要修复刚刚的 bug：</p><ul><li>所以我们需要将 master 分支和 hotfix 分支进行合并；</li></ul><p><img src="/blog/img/programming/git/merge-hotfix.jpg" alt="merge-hotfix"></p><h3 id="查看和删除分支" tabindex="-1"><a class="header-anchor" href="#查看和删除分支" aria-hidden="true">#</a> 查看和删除分支</h3><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git branch // 查看当前所有分支
git branch -v // 同时查看最后一次提交
git branch --merge // 查看所有合并到当前分支的分支
git branch -d hotfix // 删除当前分支
git branch -D hotfix // 强制删除某一分支
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="远程分支" tabindex="-1"><a class="header-anchor" href="#远程分支" aria-hidden="true">#</a> 远程分支</h3><p>远程分支是也是一种分支结构：</p><ul><li>以 &lt;remote&gt;/&lt;branch&gt; 的形式命名的； <ul><li>如果我们刚刚 clone 下来代码，分支的结构如下：</li><li>如果其他人修改了代码，那么远程分支结构如下：</li></ul></li><li>你需要通过 fetch 来获取最新的远程分支提交信息；</li></ul><p><img src="/blog/img/programming/git/remote-branch.jpg" alt="remote-branch"></p><ul><li>推送分支到远程</li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git push &lt;remote&gt; &lt;branch&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>跟踪远程分支 <ul><li>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支；</li><li>如果你愿意的话可以设置其他的跟踪分支</li><li>如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支；</li></ul></li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git checkout --track &lt;remote&gt;/&lt;branch&gt; // 跟踪其他分支
git checkout &lt;branch&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>删除远程分支</li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git push origin --delete &lt;branch&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="git-flow-git-工作流" tabindex="-1"><a class="header-anchor" href="#git-flow-git-工作流" aria-hidden="true">#</a> git flow（git 工作流）</h2><p>由于 Git 上分支的使用的便捷性，产生了很多 Git 的工作流：</p><ul><li>也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；</li><li>你可以定期地把某些主题分支合并入其他分支中；</li></ul><p>比较常见的 git flow</p><p><img src="/blog/img/programming/git/git-flow.jpg" alt="git-flow"></p><h2 id="git-rebase" tabindex="-1"><a class="header-anchor" href="#git-rebase" aria-hidden="true">#</a> Git rebase</h2><p>Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。</p><ul><li>merge 用于记录 git 的所有历史，那么分支的历史错综复杂，也全部记录下来；</li><li>rebase 用于简化历史记录，将两个分支的历史简化，整个历史更加简洁；</li></ul><p>rebase 有一条黄金法则：永远不要在主分支上使用 rebase</p><ul><li>如果在 main 上面使用 rebase，会造成大量的提交历史在 main 分支中不同；</li><li>而多人开发时，其他人依然在原来的 main 中，对于提交历史来说会有很大的变化；</li></ul><p><img src="/blog/img/programming/git/rebase.jpg" alt="rebase"></p><ul><li>在上面的图例中，你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次；</li><li>在 Git 中，这种操作就叫做 变基（rebase）；</li><li>你可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样；</li><li>rebase 这个单词如何理解呢？ <ul><li>我们可以将其理解成改变当前分支的 base；</li><li>比如在分支 experiment 上执行 rebase master，那么可以改变 experiment 的 base 为 master</li></ul></li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git checkout experiment
git rebase master
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="git-常见命令速查表" tabindex="-1"><a class="header-anchor" href="#git-常见命令速查表" aria-hidden="true">#</a> Git 常见命令速查表</h2><p><img src="/blog/img/programming/git/git-commands.jpg" alt="git-commands"></p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 177748749@qq.com">13680905763</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/blog/assets/app-b6176fc1.js" defer></script>
  </body>
</html>
