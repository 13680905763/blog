import{_ as o,M as t,p as n,q as r,R as l,t as i,N as c,a1 as e}from"./framework-204010b2.js";const s="/blog/img/web/javascript/js-base/bom/location.jpg",h={},d=e('<h1 id="bom" tabindex="-1"><a class="header-anchor" href="#bom" aria-hidden="true">#</a> bom</h1><ul><li>BOM：浏览器对象模型（Browser Object Model） <ul><li>简称 BOM，由浏览器提供的用于处理文档（document）之外的所有内容的其他对象；</li><li>比如 navigator、location、history 等对象；</li></ul></li><li>JavaScript 有一个非常重要的运行环境就是浏览器 <ul><li>而且浏览器本身又作为一个应用程序需要对其本身进行操作；</li><li>所以通常浏览器会有对应的对象模型（BOM，Browser Object Model）；</li><li>我们可以将 BOM 看成是连接 JavaScript 脚本与浏览器窗口的桥梁；</li></ul></li><li>BOM 主要包括一下的对象模型： <ul><li>window：包括全局属性、方法，控制浏览器窗口相关的属性、方法；</li><li>location：浏览器连接到的对象的位置（URL）；</li><li>history：操作浏览器的历史；</li><li>navigator：用户代理（浏览器）的状态和标识（很少用到）；</li><li>screen：屏幕窗口信息（很少用到）；</li></ul></li></ul><h2 id="window-对象" tabindex="-1"><a class="header-anchor" href="#window-对象" aria-hidden="true">#</a> window 对象</h2><ul><li>window 对象在浏览器中可以从两个视角来看待： <ol><li>全局对象。 <ul><li>我们知道 ECMAScript 其实是有一个全局对象的，这个全局对象在 Node 中是 global；</li><li>在浏览器中就是 window 对象；</li></ul></li><li>浏览器窗口对象。 <ul><li>作为浏览器窗口时，提供了对浏览器操作的相关的 API；</li></ul></li></ol></li><li>当然，这两个视角存在大量重叠的地方，所以不需要刻意去区分它们： <ul><li>事实上对于浏览器和 Node 中全局对象名称不一样的情况，目前已经指定了对应的标准，称之为 globalThis，并且大多数现代浏览器都支持它；</li><li>放在 window 对象上的所有属性都可以被访问；</li><li>使用 var 定义的变量会被添加到 window 对象中；</li><li>window 默认给我们提供了全局的函数和类：setTimeout、Math、Date、Object 等</li></ul></li></ul><h3 id="window-对象的作用" tabindex="-1"><a class="header-anchor" href="#window-对象的作用" aria-hidden="true">#</a> window 对象的作用</h3>',5),u=l("li",null,[i("事实上 window 对象上肩负的重担是非常大的： "),l("ol",null,[l("li",null,"包含大量的属性，localStorage、console、location、history、screenX、scrollX 等等（大概 60+个属性）；"),l("li",null,"包含大量的方法，alert、close、scrollTo、open 等等（大概 40+个方法）；"),l("li",null,"包含大量的事件，focus、blur、load、hashchange 等等（大概 30+个事件）；"),l("li",null,"包含从 EventTarget 继承过来的方法，addEventListener、removeEventListener、dispatchEvent 方法；")])],-1),w={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window",target:"_blank",rel:"noopener noreferrer"},p=e('<h3 id="location-对象常见的属性" tabindex="-1"><a class="header-anchor" href="#location-对象常见的属性" aria-hidden="true">#</a> location 对象常见的属性</h3><ul><li>location 对象用于表示 window 上当前链接到的 URL 信息。 <ul><li>href: 当前 window 对应的超链接 URL, 整个 URL；</li><li>protocol: 当前的协议；</li><li>host: 主机地址；</li><li>hostname: 主机地址(不带端口)；</li><li>port: 端口；</li><li>pathname: 路径；</li><li>search: 查询字符串；</li><li>hash: 哈希值；</li></ul></li></ul><h3 id="location-对象常见的方法" tabindex="-1"><a class="header-anchor" href="#location-对象常见的方法" aria-hidden="true">#</a> Location 对象常见的方法</h3><p>location 其实是 URL 的一个抽象实现：</p><p><img src="'+s+'" alt="location"></p><ul><li>location 有如下常用的方法： <ul><li>assign：赋值一个新的 URL，并且跳转到该 URL 中；</li><li>replace：打开一个新的 URL，并且跳转到该 URL 中（不同的是不会在浏览记录中留下之前的记录）；</li><li>reload：重新加载页面，可以传入一个 Boolean 类型；</li></ul></li></ul><h3 id="history-对象常见属性和方法" tabindex="-1"><a class="header-anchor" href="#history-对象常见属性和方法" aria-hidden="true">#</a> history 对象常见属性和方法</h3><ul><li>history 对象允许我们访问浏览器曾经的会话历史记录。</li><li>有两个属性： <ul><li>length：会话中的记录条数；</li><li>state：当前保留的状态值；</li></ul></li><li>有五个方法： <ul><li>back()：返回上一页，等价于 history.go(-1)；</li><li>forward()：前进下一页，等价于 history.go(1)；</li><li>go()：加载历史中的某一页；</li><li>pushState()：打开一个指定的地址；</li><li>replaceState()：打开一个新的地址，并且使用 replace；</li></ul></li></ul><h3 id="navigator-对象" tabindex="-1"><a class="header-anchor" href="#navigator-对象" aria-hidden="true">#</a> navigator 对象</h3><h3 id="screen-对象" tabindex="-1"><a class="header-anchor" href="#screen-对象" aria-hidden="true">#</a> screen 对象</h3>',10);function b(_,m){const a=t("ExternalLinkIcon");return n(),r("div",null,[d,l("ul",null,[u,l("li",null,[l("a",w,[i("更多属性、方法、事件"),c(a)])])]),p])}const f=o(h,[["render",b],["__file","bom.html.vue"]]);export{f as default};
