import{_ as n,p as a,q as s,a1 as t}from"./framework-204010b2.js";const e="/blog/img/web/javascript/js-advanced/继承/原型图.jpg",p="/blog/img/web/javascript/js-advanced/继承/原型链内存.jpg",o={},c=t(`<h1 id="继承" tabindex="-1"><a class="header-anchor" href="#继承" aria-hidden="true">#</a> 继承</h1><h2 id="object-prototype" tabindex="-1"><a class="header-anchor" href="#object-prototype" aria-hidden="true">#</a> Object Prototype</h2><p>Each object in has a special built-in attribute <code>[prototype]</code>, which can point to another object</p><p>当我们通过 key 来获取对象上的 value 时，会先在对象自身上找，如果找到就返回，找不到就去原型对象上找</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>_proto_<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="function-prototype" tabindex="-1"><a class="header-anchor" href="#function-prototype" aria-hidden="true">#</a> Function Prototype</h2><p>All functions have a prototype attribute</p><h3 id="new" tabindex="-1"><a class="header-anchor" href="#new" aria-hidden="true">#</a> new</h3><ol><li>在内存中创建一个新的对象（空对象）；</li><li>这个对象内部的<code>[[prototype]]</code>属性会被赋值为该构造函数的 prototype 属性；</li></ol><p>那么也就意味着我们通过 Person 构造函数创建出来的所有对象的<code>[[prototype]]</code>属性都指向 Person.prototype：</p><p><img src="`+e+`" alt="原型图"> 我们通常把函数放到原型上，避免 new 出重复的函数</p><h3 id="constructor" tabindex="-1"><a class="header-anchor" href="#constructor" aria-hidden="true">#</a> constructor</h3><p>By default, a property called constructor will be added to the prototype, which points to the current function object；</p><h3 id="rewrite-prototype-object" tabindex="-1"><a class="header-anchor" href="#rewrite-prototype-object" aria-hidden="true">#</a> Rewrite prototype object</h3><p>If we need to add too many attributes to the prototype, we usually rewrite the entire prototype object</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
foo<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;fafa&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
  <span class="token function-variable function">playing</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;play&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">&#39;constructor&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token literal-property property">value</span><span class="token operator">:</span> Foo
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="prototype-chain" tabindex="-1"><a class="header-anchor" href="#prototype-chain" aria-hidden="true">#</a> Prototype chain</h2><ul><li>从一个对象上获取属性，如果在当前对象中没有获取到就会去它的原型上面获取：</li></ul><p>[Object: null prototype] {} 原型有什么特殊吗？</p><ul><li>该对象有原型属性，但是它的原型属性已经指向的是 null，也就是已经是顶层原型了；</li><li>该对象上有很多默认的属性和方法；</li></ul><p><img src="`+p+`" alt="原型链内存"></p><h2 id="原型链继承" tabindex="-1"><a class="header-anchor" href="#原型链继承" aria-hidden="true">#</a> 原型链继承</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 父类构造函数</span>
<span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 被继承的属性</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;fafa&#39;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 父类原型上添加内容</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">running</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;被继承的方法&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 定义子类构造函数</span>
<span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">Son</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> p
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>缺点</p><ul><li>直接打印对象是看不到这个属性的</li><li>这个属性会被多个对象共享，如果这个对象是一个引用类型，那么就会造成问题；</li><li>不能给 Parent 传递参数</li></ul>`,25),i=[c];function l(r,u){return a(),s("div",null,i)}const k=n(o,[["render",l],["__file","extends.html.vue"]]);export{k as default};
