import{_ as r,M as s,p as n,q as t,R as a,t as l,N as o,a1 as e}from"./framework-204010b2.js";const d="/blog/img/web/javascript/js-base/运算符/算术运算符.jpg",c="/blog/img/web/javascript/js-base/运算符/原地修改.jpg",h="/blog/img/web/javascript/js-base/运算符/比较运算符.jpg",p="/blog/img/web/javascript/js-base/运算符/逻辑运算符.jpg",u={},m=e('<h1 id="运算符" tabindex="-1"><a class="header-anchor" href="#运算符" aria-hidden="true">#</a> 运算符</h1><p>JavaScript 按照使用场景的不同将运算符分成了很多种类型：</p><ul><li>算术运算符/赋值运算符/关系(比较)运算符/逻辑运算符</li></ul><h2 id="算术运算符" tabindex="-1"><a class="header-anchor" href="#算术运算符" aria-hidden="true">#</a> 算术运算符</h2><p><img src="'+d+'" alt="算术运算符"></p><h2 id="赋值运算符" tabindex="-1"><a class="header-anchor" href="#赋值运算符" aria-hidden="true">#</a> 赋值运算符</h2><p>= 是一个运算符</p><h3 id="原地修改" tabindex="-1"><a class="header-anchor" href="#原地修改" aria-hidden="true">#</a> 原地修改</h3><p><img src="'+c+'" alt="原地修改"></p><h3 id="自增、自减" tabindex="-1"><a class="header-anchor" href="#自增、自减" aria-hidden="true">#</a> 自增、自减</h3><ul><li>对一个数进行加一、减一是最常见的数学运算符之一。</li><li>所以，对此有一些专门的运算符： <ul><li>自增 ++ 将变量加 1；</li><li>自减 -- 将变量减 1；</li></ul></li><li>自增/自减只能应用于变量。 <ul><li>将其应用于数值（比如 5++）则会报错。</li></ul></li></ul><p>运算符 ++ 和 -- 可以置于变量前，也可以置于变量后。</p><ul><li>当运算符置于变量后，被称为“后置形式”（postfix form）：counter++。</li><li>当运算符置于变量前，被称为“前置形式”（prefix form）：++counter。</li><li>两者都做同一件事：将变量 counter 与 1 相加。</li></ul><p>他们有什么区别吗？</p><ul><li>有，但只有当我们使用 ++/-- 的返回值时才能看到区别；</li><li>如果自增/自减的值不会被使用，那么两者形式没有区别；</li><li>如果我们想要对变量进行自增操作，并且 需要立刻使用自增后的值，那么我们需要使用前置形式；</li><li>前置形式返回一个新的值，但后置返回原来的值；</li></ul>',15),f={id:"运算符的优先级",tabindex:"-1"},b=a("a",{class:"header-anchor",href:"#运算符的优先级","aria-hidden":"true"},"#",-1),_={href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#%E6%B1%87%E6%80%BB%E8%A1%A8",target:"_blank",rel:"noopener noreferrer"},v=e('<h2 id="比较运算符" tabindex="-1"><a class="header-anchor" href="#比较运算符" aria-hidden="true">#</a> 比较运算符</h2><p><img src="'+h+'" alt="比较运算符"></p><h3 id="和-的区别" tabindex="-1"><a class="header-anchor" href="#和-的区别" aria-hidden="true">#</a> === 和 == 的区别</h3><ul><li>普通的相等性检查 == 存在一个问题，它不能区分出 0 和 false，或者空字符串和 false 这类运算： <ul><li>这是因为在比较不同类型的值时，处于判断符号 == 两侧的值会先被转化为数字；</li><li>空字符串和 false 也是如此，转化后它们都为数字 0；</li></ul></li><li>如果我们需要区分 0 和 false，该怎么办？ <ul><li>严格相等运算符 === 在进行比较时不会做任何的类型转换；</li><li>换句话说，如果 a 和 b 属于不同的数据类型，那么 a === b 不会做任何的类型转换而立刻返回 false；</li></ul></li><li>同样的，“不相等”符号 != 类似，“严格不相等”表示为 !==。</li><li>严格相等的运算符虽然写起来稍微长一些，但是它能够很清楚地显示代码意图，降低你犯错的可能性</li></ul><h2 id="逻辑运算符" tabindex="-1"><a class="header-anchor" href="#逻辑运算符" aria-hidden="true">#</a> 逻辑运算符</h2><p>逻辑运算符，主要是由三个：</p><ul><li>||（或），&amp;&amp;（与），!（非）</li><li>它可以将多个表达式或者值放到一起来获取到一个最终的结果；</li></ul><p><img src="'+p+`" alt="逻辑运算符"></p><ul><li>有了逻辑运算符，我们就可以在判断语句中编写多个条件。</li></ul><h3 id="逻辑或的本质" tabindex="-1"><a class="header-anchor" href="#逻辑或的本质" aria-hidden="true">#</a> 逻辑或的本质</h3><ul><li>||（或）两个竖线符号表示“或”运算符（也称为短路或）： <ul><li>从左到右依次计算操作数。</li><li>处理每一个操作数时，都将其转化为布尔值（Boolean）；</li><li>如果结果是 true，就停止计算，返回这个操作数的初始值。</li><li>如果所有的操作数都被计算过（也就是，转换结果都是 false），则返回最后一个操作数。</li></ul></li><li>注意：返回的值是操作数的初始形式，不会转换为 Boolean 类型。</li><li>换句话说，一个或运算 || 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> showName <span class="token operator">=</span> name <span class="token operator">||</span> defaultName
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="逻辑与的本质" tabindex="-1"><a class="header-anchor" href="#逻辑与的本质" aria-hidden="true">#</a> 逻辑与的本质</h3><ul><li>&amp;&amp;（或）两个竖线符号表示“与”运算符（也称为短路与）： <ul><li>从左到右依次计算操作数。</li><li>在处理每一个操作数时，都将其转化为布尔值（Boolean）；</li><li>如果结果是 false，就停止计算，并返回这个操作数的初始值（一般不需要获取到初始值）；</li><li>如果所有的操作数都被计算过（例如都是真值），则返回最后一个操作数。</li></ul></li><li>换句话说，与运算 返回第一个假值，如果没有假值就返回最后一个值。</li></ul><h3 id="非" tabindex="-1"><a class="header-anchor" href="#非" aria-hidden="true">#</a> !（非）</h3><ul><li>逻辑非运算符接受一个参数，并按如下运算： <ol><li>将操作数转化为布尔类型：true/false；</li><li>返回相反的值；</li></ol></li><li>两个非运算 !! 有时候用来将某个值转化为布尔类型： <ul><li>也就是，第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反。</li><li>最后我们就得到了一个任意值到布尔值的转化。</li></ul></li></ul><h2 id="三元运算符" tabindex="-1"><a class="header-anchor" href="#三元运算符" aria-hidden="true">#</a> 三元运算符</h2><ul><li><p>有时我们需要根据一个条件去赋值一个变量。</p><ul><li>比如比较数字大小的时候，获取较大的数字；</li><li>这个时候 if else 语句就会显得过于臃肿，有没有更加简介的方法呢？</li></ul></li><li><p>条件运算符：’?’</p><ul><li>这个运算符通过问号 ? 表示；</li><li>有时它被称为三元运算符，被称为“三元”是因为该运算符中有三个操作数（运算元）；</li><li>实际上它是 JavaScript 中唯一一个有这么多操作数的运算符；</li></ul></li><li><p>使用格式如下:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> result <span class="token operator">=</span> condition <span class="token operator">?</span> value1 <span class="token operator">:</span> value2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>计算条件结果，如果结果为真，则返回 value1，否则返回 value2。</li></ul></li></ul>`,18);function g(x,j){const i=s("ExternalLinkIcon");return n(),t("div",null,[m,a("h2",f,[b,l(),a("a",_,[l("运算符的优先级"),o(i)])]),v])}const B=r(u,[["render",g],["__file","operator.html.vue"]]);export{B as default};
