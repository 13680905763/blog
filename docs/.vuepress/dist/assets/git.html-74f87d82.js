import{_ as i,p as e,q as a,a1 as l}from"./framework-204010b2.js";const t="/blog/img/programming/git/status.jpg",d="/blog/img/programming/git/commit1.jpg",s="/blog/img/programming/git/commit2.jpg",r="/blog/img/programming/git/commit3.jpg",n="/blog/img/programming/git/cat-file.jpg",g="/blog/img/programming/git/head.jpg",c="/blog/img/programming/git/notrack.jpg",o="/blog/img/programming/git/set-upstream-to.jpg",m="/blog/img/programming/git/拒绝合并不相干历史.jpg",u="/blog/img/programming/git/allow-unrelated-histories.jpg",h="/blog/img/programming/git/master.jpg",p="/blog/img/programming/git/test-branch.jpg",v="/blog/img/programming/git/head-branch.jpg",b="/blog/img/programming/git/test-commit.jpg",f="/blog/img/programming/git/checkout-master.jpg",x="/blog/img/programming/git/master-commit.jpg",_="/blog/img/programming/git/hotfix.jpg",j="/blog/img/programming/git/merge-hotfix.jpg",G={},k=l(`<h1 id="how-to-use-git" tabindex="-1"><a class="header-anchor" href="#how-to-use-git" aria-hidden="true">#</a> how to use git</h1><h2 id="concept" tabindex="-1"><a class="header-anchor" href="#concept" aria-hidden="true">#</a> concept</h2><h3 id="集中式版本控制" tabindex="-1"><a class="header-anchor" href="#集中式版本控制" aria-hidden="true">#</a> 集中式版本控制</h3><p>CVS 和 SVN 都是是属于集中式版本控制系统</p><ol><li>单一的<strong>集中管理的服务器</strong>，保存所有文件的修订版本；</li><li>开发人员通过客户端连接到这台服务器，取出最新的文件或者提交更新；</li></ol><ul><li>相较于老式的本地管理来说，每个人都可以在一定程度上看到项目中的 其他人正在做些什么。</li><li>有一个核心的问题：中央服务器不能出现故障： <ol><li>如果宕机一小时，那么在这一小时内，谁都无法提 交更新，也就无法协同工作；</li><li>如果中心数据库所在的磁盘发生损坏，又没有做恰 当备份，毫无疑问你将丢失所有数据；</li></ol></li></ul><h3 id="分布式版本控制" tabindex="-1"><a class="header-anchor" href="#分布式版本控制" aria-hidden="true">#</a> 分布式版本控制</h3><ul><li>客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下 来，包括完整的历史记录；</li><li>任何一处协同工作用的服务器发生故障，事后都可以用任何 一个镜像出来的本地仓库恢复；</li><li>因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份；</li></ul><h2 id="bash-–-cmd-–-gui" tabindex="-1"><a class="header-anchor" href="#bash-–-cmd-–-gui" aria-hidden="true">#</a> Bash – CMD – GUI</h2><ul><li>Git Bash 是基于 CMD 的，在 CMD 的基础上增添一些新的命令与功能；</li><li>Git CMD 命令行提示符（CMD）是 Windows 操作系统上的命令行解释程序</li><li>Git GUI 提供了一个图形用户界面来运行 git 命令；</li></ul><h2 id="config" tabindex="-1"><a class="header-anchor" href="#config" aria-hidden="true">#</a> config</h2><h3 id="username-usereamil" tabindex="-1"><a class="header-anchor" href="#username-usereamil" aria-hidden="true">#</a> username usereamil</h3><ul><li>每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改；</li><li>如果使用了 --global 选项，那么该命令只需要运行一次，之后无论你在该系统上做任何事情，Git 都会使用那些信息；</li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git config --global user.name <span class="token string">&#39;ZhangYuHua&#39;</span>
git config --global user.email <span class="token string">&#39;177748749@qq.com&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>检测当前配置信息</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git config --list
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="alias" tabindex="-1"><a class="header-anchor" href="#alias" aria-hidden="true">#</a> alias</h3><p>如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commmit
git config --global alias.st status
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="init" tabindex="-1"><a class="header-anchor" href="#init" aria-hidden="true">#</a> init</h2><ol><li>初始化仓库 git init</li><li>从远程克隆仓库 git clone</li></ol><h2 id="文件的状态" tabindex="-1"><a class="header-anchor" href="#文件的状态" aria-hidden="true">#</a> 文件的状态</h2><p>在 git 仓库中会对文件划分不同的状态</p><ol><li>Untracked:未跟踪, 此文件在文件夹中, 但并没有加入到 git 库, 不参与版本控制. 通过 git add 状态变为 Staged</li><li>Staged: 暂存状态. <ul><li>执行 git commit 则将修改同步到库中, 文件为 Unmodified 状态</li><li>执行 git reset HEAD filename 取消暂存, 文件状态为 Modified</li></ul></li><li>Unmodified：文件已经入库, 库中的文件和本地文件又变为一致. <ul><li>如果它被修改, 而变为 Modified.</li><li>执行 git rm 移出版本库, 则成为 Untracked 文件</li></ul></li><li>Modified：文件已修改, 仅仅是修改, 并没有进行其他的操作. <ul><li>执行 git add 可进入暂存 staged 状态,</li><li>执行 git checkout（从库中取出文件, 覆盖当前修改） 则丢弃修改过, 返回到 Unmodified 状态</li></ul></li></ol><p><img src="`+t+`" alt="status"></p><h3 id="检测文件的状态" tabindex="-1"><a class="header-anchor" href="#检测文件的状态" aria-hidden="true">#</a> 检测文件的状态</h3><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git status
git status --short
git status -s
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="git-忽略文件" tabindex="-1"><a class="header-anchor" href="#git-忽略文件" aria-hidden="true">#</a> git 忽略文件</h2><p>有些文件我们无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。</p><ul><li>通常都是些自动生成的文件，比如依赖文件，日志文件，或者编译过程中创建 的临时文件等；</li><li>我们可以创建一个名为 <strong>.gitignore</strong> 的文件，列出要忽略的文件的模 式；</li></ul><h2 id="git-add" tabindex="-1"><a class="header-anchor" href="#git-add" aria-hidden="true">#</a> git add</h2><p>文件添加到暂存区</p><ul><li>跟踪新文件</li><li>跟踪已修改的文件</li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code> git add xx.js
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>将所有的文件添加到暂存区</li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code> git add .
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="git-commit" tabindex="-1"><a class="header-anchor" href="#git-commit" aria-hidden="true">#</a> git commit</h2><p>暂存区已经准备就绪，可以提交了</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git commit –m <span class="token string">&quot;提交信息&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>add 跟 commit 一起使用</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git commit -a -m <span class="token string">&quot;提交信息&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="commit-object" tabindex="-1"><a class="header-anchor" href="#commit-object" aria-hidden="true">#</a> commit Object</h3><p>在进行提交操作时，Git 会保存一个提交对象（commit object）：</p><ul><li>该提交对象会包含一个指向暂存内容快照的指针(校验和)；</li><li>该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针； <ul><li>首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象；</li><li>而由多个分支合并产生的提交对象有多个父对象；</li></ul></li></ul><p><img src="`+d+'" alt="commit1"><img src="'+s+'" alt="commit2"><img src="'+r+`" alt="commit3"></p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git cat-file -t 文件名（二进制，前几位就行）// 看文件类型
git cat-file -p 文件名 // 看文件内容
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+n+`" alt="cat-file"></p><h2 id="git-校验和" tabindex="-1"><a class="header-anchor" href="#git-校验和" aria-hidden="true">#</a> git 校验和</h2><p>Git 中所有的数据在存储前都计算校验和，然后以 校验和 来引用。</p><ul><li>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）；</li><li>这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来；</li></ul><h2 id="git-log" tabindex="-1"><a class="header-anchor" href="#git-log" aria-hidden="true">#</a> git log</h2><p>要查看一下所有的历史提交记录。</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git log //列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明
git log --pretty=oneline // 只显示哈希值和提交说明
git log --pretty=oneline --graph // 可以看merge
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="git-reset" tabindex="-1"><a class="header-anchor" href="#git-reset" aria-hidden="true">#</a> git reset</h2><p>版本回退 HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交； <img src="`+g+`" alt="HEAD"> 通过 HEAD 来改变 Git 目前的版本指向：</p><ul><li>上一个版本就是 HEAD^，上上一个版本就是 HEAD^^；</li><li>如果是上 1000 个版本，我们可以使用 HEAD~1000；</li><li>我们可以可以指定某一个 commit id；</li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git reset --hard HEAD^
git reset --hard HEAD~1000
git reset --hard 2d44982
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="远程仓库" tabindex="-1"><a class="header-anchor" href="#远程仓库" aria-hidden="true">#</a> 远程仓库</h2><p>多人开发中我们会将管理的代码共享到远程仓库中；</p><p>对于私有的仓库我们想要进行操作，远程仓库会对我们的身份进行验证：</p><ol><li>基于 HTTP 的凭证存储（Credential Storage）；</li><li>基于 SSH 的密钥；</li></ol><h3 id="凭证" tabindex="-1"><a class="header-anchor" href="#凭证" aria-hidden="true">#</a> 凭证</h3><p>HTTP 协议是无状态的连接，所以每一个连接都需要用户名和密码：</p><ul><li>如果每次都这样操作，那么会非常麻烦；</li><li>幸运的是，Git 拥有一个凭证系统来处理这个事情；</li></ul><h3 id="ssh-密钥" tabindex="-1"><a class="header-anchor" href="#ssh-密钥" aria-hidden="true">#</a> SSH 密钥</h3><p>Secure Shell（安全外壳协议，简称 SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。 SSH 以非对称加密实现身份验证。</p><ul><li>例如其中一种方法是使用自动生成的公钥-私钥对来简单地加密网络连接，随后使用密码认证进行登录；</li><li>另一种方法是人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录；</li><li>公钥需要放在待访问的电脑之中，而对应的私钥需要由用户自行保管；</li></ul><p>如果我们以 SSH 的方式访问 Git 仓库，那么就需要生产对应的公钥和私钥</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>ssh-keygen -t ed25519 -C “your email&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="管理远程服务器" tabindex="-1"><a class="header-anchor" href="#管理远程服务器" aria-hidden="true">#</a> 管理远程服务器</h3><p>查看远程仓库</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git remote
git remote -v
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>添加远程仓库</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git remote add &lt;shortname&gt; &lt;url&gt;
git remote add origin https://github.com/13680905763/blog.git
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>重命名远程仓库</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git remote rename origin 666
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>移除远程仓库</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git remote remove origin
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="本地分支的上游分支-跟踪分支" tabindex="-1"><a class="header-anchor" href="#本地分支的上游分支-跟踪分支" aria-hidden="true">#</a> 本地分支的上游分支（跟踪分支）</h3><p>本地的主分支是 master，远程的主分支是 main</p><p>当我们在本地进行 git pull（git pull = git fetch + git merge） 时</p><p>(git fetch 从远程获取新数据，到 git)提示我们当前分支没有 track 的分支</p><p><img src="`+c+`" alt="notrack"></p><p>我们设置本地 master 分支跟踪远程 main 分支</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git branch --set-upstream-to=origin/main
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+o+'" alt="set-upstream-to"></p><p>继续 git pull</p><p>(git merge 合并从远程拿到的新数据到当前分支，更新目录)提示我们拒绝合并不相干的历史</p><p><img src="'+m+`" alt="拒绝合并不相干历史"></p><p>我们可以通过--allow-unrelated-histories 选项来允许合并两个不相关的历史；</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git merge allow-unrelated-histories
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+u+`" alt="allow-unrelated-histories"></p><h3 id="远程仓库的交互" tabindex="-1"><a class="header-anchor" href="#远程仓库的交互" aria-hidden="true">#</a> 远程仓库的交互</h3><ul><li>从远程仓库 clone 代码</li><li>将代码 push 到远程仓库：将本地仓库的代码推送到远程仓库中；</li><li>从远程仓库 fetch 代码：从远程仓库获取最新的代码</li><li>获取到代码后默认并没有合并到本地仓库，我们需要通过 merge 来合并；</li><li>从远程仓库 pull 代码：上面的两次操作有点繁琐，我们可以通过一个命令来操作</li></ul><h2 id="合并冲突" tabindex="-1"><a class="header-anchor" href="#合并冲突" aria-hidden="true">#</a> 合并冲突</h2><p>文件冲突时，需要合并</p><h2 id="tag" tabindex="-1"><a class="header-anchor" href="#tag" aria-hidden="true">#</a> tag</h2><p>对于重大的版本我们常常会打上一个标签，以表示它的重要性：</p><ul><li>Git 可以给仓库历史中的某一个提交打上标签；</li><li>比较有代表性的是人们会使用这个功能来标记发布结点（ v1.0 、 v2.0 等等）；</li></ul><p>创建标签：</p><ul><li>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）；</li><li>附注标签：通过-a 选项，并且通过-m 添加额外信息；</li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git tag v1.0
git tag -a v1.0 -m <span class="token string">&#39;附注标签&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>默认情况下，git push 不会传送标签到远程仓库服务器上。</p><ul><li>在创建标签后你必推送标签到远程仓库，其他人从仓库中克隆或拉取时也能得到标签；</li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git push origin v1.0
git push origin --tags // 推送所有标签
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>删除标签</p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git tag -d v1.0 // 删除本地标签
git push origin --delete v1.0 //删除远程标签
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>检出标签</p><ul><li>查看某个标签所指向的文件版本，可以使用 git checkout 命令；</li><li>通常我们在检出 tag 的时候还会创建一个对应的分支（修复 bug）；</li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git checkout v1.0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="branch" tabindex="-1"><a class="header-anchor" href="#branch" aria-hidden="true">#</a> branch</h2><h3 id="master-分支" tabindex="-1"><a class="header-anchor" href="#master-分支" aria-hidden="true">#</a> master 分支</h3><p>Git 的分支，其实本质上是指向 commit object 的可变指针。</p><ul><li>Git 的默认分支名字是 master，在多次提交操作之后，master 分支始终指向最新的提交</li></ul><p>Git 的 master 分支并不是一个特殊分支。</p><ul><li>它就跟其它分支完全没有区别；</li><li>之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它；</li></ul><p><img src="`+h+'" alt="master"></p><h3 id="创建分支" tabindex="-1"><a class="header-anchor" href="#创建分支" aria-hidden="true">#</a> 创建分支</h3><p>Git 是怎么创建新分支的呢？</p><ul><li>很简单，它只是为你创建了一个可以移动的新的指针； <ul><li>比如，创建一个 testing 分支， 你需要使用 git branch 命令：</li></ul></li></ul><p><img src="'+p+`" alt="test-branch"></p><ul><li>那么，Git 又是怎么知道当前在哪一个分支上呢？ <ul><li>也很简单，它也是通过一个名为 HEAD 的特殊指针；</li></ul></li></ul><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git checkout testing
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="`+v+'" alt="head-branch"></p><h3 id="分支提交" tabindex="-1"><a class="header-anchor" href="#分支提交" aria-hidden="true">#</a> 分支提交</h3><p>如果我们切换分支，并在这个分支上提交</p><p><img src="'+b+'" alt="test-commit"></p><p>切回 master 开发</p><p><img src="'+f+'" alt="checkout-master"><img src="'+x+`" alt="master-commit"></p><div class="language-git line-numbers-mode" data-ext="git"><pre class="language-git"><code>git checkout -b &lt;newbranch&gt; // 创建分支并切换分支
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="为什么使用分支" tabindex="-1"><a class="header-anchor" href="#为什么使用分支" aria-hidden="true">#</a> 为什么使用分支</h3><p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。</p><ul><li>开发某个项目，在默认分支 master 上进行开发；</li><li>实现项目的功能需求，不断提交；</li><li>并且在一个大的版本完成时，发布版本，打上一个 tag v1.0.0；</li></ul><p>继续开发后续的新功能，突然线上 v1.0 出现了 bug 需要紧急修补</p><ul><li>切换到 tag v1.0.0 的版本，并且创建一个分支 hotfix；</li></ul><p><img src="`+_+'" alt="hotfix"></p><p>分支上开发、修复 bug：</p><ul><li>我们可以在创建的 hotfix 分支上继续开发工作或者修复 bug；</li><li>当完成要做的工作后，重新打上一个新的 tag v1.0.1；</li></ul><p>切换回 master 分支，但是这个时候 master 分支也需要修复刚刚的 bug：</p><ul><li>所以我们需要将 master 分支和 hotfix 分支进行合并；</li></ul><p><img src="'+j+'" alt="merge-hotfix"></p>',141),H=[k];function S(D,A){return e(),a("div",null,H)}const w=i(G,[["render",S],["__file","git.html.vue"]]);export{w as default};
