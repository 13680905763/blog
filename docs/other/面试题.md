# 面试题

## HTML

## CSS

## JavaScript

### this 绑定

### 变量提升、函数提升

变量提升：

- 简单说就是在 js 代码执⾏前引擎会先进⾏预编译，预编译期间会将变量声明与函数声明提升⾄其对
  应作⽤域的最顶端，函数内声明的变量只会提升⾄该函数作⽤域最顶层。
- 当函数内部定义的⼀个变量与外部相同时，那么函数体内的这个变量就会被上升到最顶端。

函数提升：

- 函数提升只会提升函数声明式写法，函数表达式的写法不存在函数提升。
- 函数提升的优先级⼤于变量提升的优先级，即函数提升在变量提升之上。

### GO/AO/VO 的理解

GO

- Global Object JS 代码在执⾏前会现在堆内存中创建⼀个全局对象(GO)
- ⽤于存放⼀些定义好的变量⽅法等包含 Date Array String Number setTimeout 等
- 同时有⼀个 window 属性指向⾃⼰
- 同时在语法分析转成 AST 的过程中也会将⼀些变量 函数 存放在 GO 中 只是变量的初始值为 undefined

AO

- 函数在执⾏前会先在堆内存中创建⼀个 AO(Activation Object)对象 ⾥⾯存放这 arguments 对应函数的形参 以及在函数中定义的变量 初始值为 undefined

VO

- Variable Object 在执⾏函数时 会在执⾏上下⽂栈(ECS)中进⼊⼀个函数执⾏上下⽂(FEC)其中有三个核⼼ 核⼼之⼀是 VO 指向的是该函数在内存中解析时创建的 AO ⽽在全局执⾏上下⽂中指向的是 GO

### 作⽤域和作⽤域链的理解

作⽤域

- 在 ES5 中，全局是⼀个作⽤域，函数也会产⽣作⽤域。
- 在 ES6 中，代码块、let、const 等都会有属于⾃⼰的作⽤域。

作⽤域链

- 当进⼊到⼀个执⾏上下⽂时，执⾏上下⽂会关联⼀个作⽤域链。
- 通常作⽤域链在解析时就被确定，作⽤域链与函数的定义位置有关，与它的调⽤位置⽆关

### 如何理解闭包的,闭包到底是什么?

- ⼀个普通的函数 function，如果它可以访问外层作⽤域的⾃由变量，那么这个函数和周围环境就是⼀个闭包。
- 应⽤场景:防抖 、节流 、⽴即执⾏函数 、组合函数等等

### 数组扁平化

```javaScript
var arr = [1,2,[3,4]]
var result = []
result = [].concat(...arr)
result = arr.flat()
```

### 数组去重

```javaScript
function unique (arr) {
  return Array.from(new Set(arr))
}
function unique(arr) {
  for(var i=0; i<arr.length; i++){
        for(var j=i+1; j<arr.length; j++){
                if(arr[i]==arr[j]){ //第⼀个等同于第⼆个，splice⽅法删除第⼆个
                    arr.splice(j,1);
                    j--;
                  }
              }
        }
  return arr;
}
```

## TS

## React

## 网络

<!-- ## 前端工程化 -->

### 模块化开发的理解

- 模块化开发最终的⽬的是将程序划分成⼀个个⼩的结构(模块)
- 这个结构中编写属于⾃⼰的逻辑代码，有⾃⼰的作⽤域，定义变量名词时不会影响到其他的结构
- 可导出变量,函数,对象等给其他模块⽤，也可导⼊其他模块中的变量,函数,对象
- 按照这种结构划分开发程序的过程，就是模块化开发的过程
- 早期是没有模块化, 带来⼀些问题
  - 命名冲突 -> ⽴即执⾏函数 -> ⾃定义模块 -> 没有规范
  - 社区中模块化规范: CommonJS/AMD/CMD
  - ES6 中推出模块化: ES Module

### 什么是 yarn 和 npm？为什么要⽤ yarn 代替 npm 呢？

- npm 是与 Node.js ⾃带的默认包管理器，它有⼀个⼤型的公共库和私有库，存储在 npm registry 的数据库中，⽤户可以通过 npm 命令⾏访问该仓库。在 npm 的帮助下，⽤户可以轻松管理项⽬中的依赖项。
- yarn 也是⼀个包管理器，是由 Facebook、Google、Exponent 和 Tilde 联合推出了⼀个新的 JS 包
  管理⼯具，它有如下的优点：
  1. 速度快，⽀持并⾏安装。⽆论 npm 还是 Yarn 在执⾏包的安装时，都会执⾏⼀系列任务。
     npm 是按照队列执⾏每个 package，也就是说必须要等到当前 package 安装完成之后，才
     能继续后⾯的安装。⽽ Yarn 是同步执⾏所有任务，提⾼了性能。
  2. 离线模式，如果之前已经安装过⼀个软件包，⽤ Yarn 再次安装时之间从缓存中获取，就不⽤
     像 npm 那样再从⽹络下载了。
- yarn 是为了弥补 早期 npm 的⼀些缺陷⽽出现的，⽐如安装依赖速度很慢、版本依赖混乱等等⼀系列的问题， npm5 版本开始，进⾏了很多的升级和改进。

### npm install 的安装过程

执⾏ npm install 会检测是有 package-lock.json ⽂件：

1. 没有 lock ⽂件
   - 分析依赖关系，这是因为我们可能包会依赖其他的包，并且多个包之间会产⽣相同依赖的情况；
   - 从 registry 仓库中下载压缩包（如果我们设置了镜像，那么会从镜像服务器下载压缩包）；
   - 获取到压缩包后会对压缩包进⾏缓存（从 npm5 开始有的）；
   - 将压缩包解压到项⽬的 node_modules ⽂件夹中（前⾯我们讲过，require 的查找顺序会在该包下⾯查找）
1. 有 lock ⽂件
   - 检测 lock 中包的版本是否和 package.json 中⼀致（会按照 semver 版本规范检测）
   - 不⼀致，那么会重新构建依赖关系，直接会⾛顶层的流程
   - ⼀致的情况下，会去优先查找缓存
     - 没有找到，会从 registry 仓库下载，直接⾛顶层流程
     - 查找到，会获取缓存中的压缩⽂件，并且将压缩⽂件解压到 node_modules ⽂件夹中

### 什么是 pnpm？为什么说 pnpm ⾼性能？

- pnpm 是⼀个快速、节省磁盘空间的软件包管理器，特点是：快速、⾼效，并⽀持 monorepo 等等。
- 当使⽤ npm 或 Yarn 时，如果你有 100 个项⽬，并且所有项⽬都有⼀个相同的依赖包，那么， 你在硬盘上就需要保存 100 份该相同依赖包的副本。为了解决上⾯的问题，就出现了 pnpm，使⽤ pnpm 安装的依赖包将被存放在⼀个统⼀的位置。
  - 当安装软件包时， 其包含的所有⽂件都会硬链接到此位置，⽽不会占⽤额外的硬盘空间
  - pnpm 是软连接和硬链接相结合，⽅便在项⽬之间共享相同版本的依赖包

<!-- ## Git -->

<!-- ### 常见 git 命令 -->

### git flow

由于 Git 上分支的使用的便捷性，产生了很多 Git 的工作流：

- master 分支：主要包含最近发布到生产环境的代码，最近发布的 release，这个分支只能从其他分支合并，不能在这个分支直接修改
- develop 分支：主要开发分支，包含所有要发布到下一个 release 的代码
- feature 分支：开发一个新的功能，一旦开发完成，合并回 develop 分支
- release 分支：当需要发布新的测试版本，我们基于 develop 分支创建一个 release 分支，完成 release 后，我们合并到 master 和 develop
- hotfix 分支：当我们在 master 发现新的 bug 时，我们需要创建一个 hotfix，完成 hotfix 后，合并回 master 和 develop 分支，所以 hotfix 的改动回进入下一个 release
